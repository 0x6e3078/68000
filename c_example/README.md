This is an example of a C program that run on a standalone 68000-based
computer like my TS2 or the Motorola Educational Computer Board (ECB).

You will need a version of gcc built as a cross-compiler for the 68k
platform. I used gcc version 5.4.0.

Build the code using the provided make file.

It gets linked at address 0. To load it into the Motorola ECB TUTOR
monitor you can the set an offset register so that it will get loaded
at a location in RAM that won't overwrite the vector table, like
$1000. This works because the code generated by gcc is position
independent. Do this by running this TUTOR command:

.R0 1000

Then run the load command from TUTOR, specifying the console port:

LO1

Now send the run file to the serial port. On a Linux desktop system
using the first USB serial port, this command works well:

% ascii-xfr -s -l 100 demo.run > /dev/ttyUSB0 

After this you'll probably want to reset R0 to zero to avoid confusion
with all commands having an offset added, i.e.

.R0 -1000

You can now run the program from TUTOR. For this example, the main
function starts at address $1032 (at least for the version of gcc I
used). Here is a sample disassembly:

TUTOR  1.3 > MD 1000 8B ;DI
001000    4865                 DC.W    $4865 
001002    6C6C                 BGE.S   $001070 
001004    6F000008             BLE.L   $00100E 
001008    3D40FFFE             MOVE.W  D0,-2(A6) 
00100C    4A6EFFFE             TST.W   -2(A6) 
001010    6E04                 BGT.S   $001016 
001012    7001                 MOVEQ.L #1,D0 
001014    6018                 BRA.S   $00102E 
001016    302EFFFE             MOVE.W  -2(A6),D0 
00101A    5340                 SUBQ.W  #1,D0 
00101C    3040                 MOVE.W  D0,A0 
00101E    2F08                 MOVE.L  A0,-(A7) 
001020    4EBAFFDE             JSR     $00001000(PC) 
001024    588F                 ADDQ.L  #4,A7 
001026    3200                 MOVE.W  D0,D1 
001028    302EFFFE             MOVE.W  -2(A6),D0 
00102C    C1C1                 MULS.W  D1,D0 
00102E    4E5E                 UNLK    A6 
001030    4E75                 RTS      
001032    4E56FFF0             LINK    A6,#-16 
001036    3D7C0001FFFE         MOVE.W  #1,-2(A6) 
00103C    3D7C0002FFFC         MOVE.W  #2,-4(A6) 
001042    1D7C0041FFFB         MOVE.B  #65,-5(A6) 
001048    2D7C000004D2FFF6     MOVE.L  #1234,-10(A6) 
001050    2D7C00000000FFF2     MOVE.L  #0,-14(A6) 
001058    3D7C0001FFFE         MOVE.W  #1,-2(A6) 
00105E    601A                 BRA.S   $00107A 
001060    306EFFFE             MOVE.W  -2(A6),A0 
001064    2F08                 MOVE.L  A0,-(A7) 
001066    4EBAFF98             JSR     $00001000(PC) 
00106A    588F                 ADDQ.L  #4,A7 
00106C    3D40FFFC             MOVE.W  D0,-4(A6) 
001070    302EFFFE             MOVE.W  -2(A6),D0 
001074    5240                 ADDQ.W  #1,D0 
001076    3D40FFFE             MOVE.W  D0,-2(A6) 
00107A    0C6E0007FFFE         CMP.W   #7,-2(A6) 
001080    6FDE                 BLE.S   $001060 
001082    306EFFFC             MOVE.W  -4(A6),A0 
001086    2008                 MOVE.L  A0,D0 
001088    4E5E                 UNLK    A6 
00108A    4E75                 RTS

Before running you should set the stack pointer to a valid
location in RAM, e.g.

.A7 4000

The program produces no output because there are no i/o routines, so
it is more useful to trace or single step.

If you want to see an assembler listing annotated with the
C source code, you can compile with debug, e.g.

% m68k-elf-gcc -g -m68000 -S demo.c

Then run the m68k-elf-objdump command with options to disassemble and
show source code, e.g.

% m68k-elf-objdump -D -S demo.o

demo.o:     file format elf32-m68k

Disassembly of section .text:
00000000 <factorial>:
  or other run-time code.
*/

short factorial(short n) {
   0:	4e56 fffc      	linkw %fp,#-4
   4:	202e 0008      	movel %fp@(8),%d0
   8:	3d40 fffe      	movew %d0,%fp@(-2)
    if (n <= 0) {
   c:	4a6e fffe      	tstw %fp@(-2)
  10:	6e04           	bgts 16 <factorial+0x16>
        return 1;
  12:	7001           	moveq #1,%d0
  14:	6018           	bras 2e <factorial+0x2e>
    } else {
       return(n * factorial(n - 1));
  16:	302e fffe      	movew %fp@(-2),%d0
  1a:	5340           	subqw #1,%d0
  1c:	3040           	moveaw %d0,%a0
  1e:	2f08           	movel %a0,%sp@-
  20:	4eba ffde      	jsr %pc@(0 <factorial>)
  24:	588f           	addql #4,%sp
  26:	3200           	movew %d0,%d1
  28:	302e fffe      	movew %fp@(-2),%d0
  2c:	c1c1           	mulsw %d1,%d0
    }
}
  2e:	4e5e           	unlk %fp
  30:	4e75           	rts

00000032 <main>:
int main()
{
  32:	4e56 fff0      	linkw %fp,#-16
    short i = 1;
  36:	3d7c 0001 fffe 	movew #1,%fp@(-2)
    short j = 2;
  3c:	3d7c 0002 fffc 	movew #2,%fp@(-4)
    char  c = 'A';
  42:	1d7c 0041 fffb 	moveb #65,%fp@(-5)
    long  l = 1234;
  48:	2d7c 0000 04d2 	movel #1234,%fp@(-10)
  4e:	fff6 
    char *s = "Hello";
  50:	2d7c 0000 0000 	movel #0,%fp@(-14)
  56:	fff2 

    for (i = 1; i < 8; i++) {
  58:	3d7c 0001 fffe 	movew #1,%fp@(-2)
  5e:	601a           	bras 7a <main+0x48>
        j = factorial(i);
  60:	306e fffe      	moveaw %fp@(-2),%a0
  64:	2f08           	movel %a0,%sp@-
  66:	4eba ff98      	jsr %pc@(0 <factorial>)
  6a:	588f           	addql #4,%sp
  6c:	3d40 fffc      	movew %d0,%fp@(-4)
    for (i = 1; i < 8; i++) {
  70:	302e fffe      	movew %fp@(-2),%d0
  74:	5240           	addqw #1,%d0
  76:	3d40 fffe      	movew %d0,%fp@(-2)
  7a:	0c6e 0007 fffe 	cmpiw #7,%fp@(-2)
  80:	6fde           	bles 60 <main+0x2e>
    }
    return j;
  82:	306e fffc      	moveaw %fp@(-4),%a0
  86:	2008           	movel %a0,%d0
}
  88:	4e5e           	unlk %fp
  8a:	4e75           	rts

Disassembly of section .rodata:
00000000 <.rodata>:
short factorial(short n) {
   0:	4865           	.short 0x4865
   2:	6c6c           	bges 70 <main+0x3e>
   4:	6f00           	bles 6 <factorial+0x6>

Disassembly of section .debug_info:
00000000 <.debug_info>:
   0:	0000 00c0      	orib #-64,%d0
   4:	0004 0000      	orib #0,%d4
   8:	0000 0401      	orib #1,%d0
    if (n <= 0) {
   c:	0000 0000      	orib #0,%d0
  10:	0c00 0000      	cmpib #0,%d0
	...
       return(n * factorial(n - 1));
  20:	8c00           	orb %d0,%d6
  22:	0000 0002      	orib #2,%d0
  26:	0000 0000      	orib #0,%d0
  2a:	0109 0000      	movepw %a1@(0),%d0
}
  2e:	004b           	.short 0x004b
  30:	0000 0000      	orib #0,%d0
{
  34:	0000 0032      	orib #50,%d0
    short i = 1;
  38:	019c           	bclr %d0,%a4@+
  3a:	0000 004b      	orib #75,%d0
    short j = 2;
  3e:	036e 0001      	bchg %d1,%fp@(1)
    char  c = 'A';
  42:	0900           	btst %d4,%d0
  44:	0000 4b02      	orib #2,%d0
    long  l = 1234;
  48:	7e7e           	moveq #126,%d7
  4a:	0004 0205      	orib #5,%d4
  4e:	0000 0000      	orib #0,%d0
    char *s = "Hello";
  52:	0500           	btst %d2,%d0
  54:	0000 0001      	orib #1,%d0
    for (i = 1; i < 8; i++) {
  58:	1100           	moveb %d0,%a0@-
  5a:	0000 a800      	orib #0,%d0
  5e:	0000 0000      	orib #0,%d0
        j = factorial(i);
  62:	0000 5a01      	orib #1,%d0
  66:	9c00           	subb %d0,%d6
  68:	0000 a806      	orib #6,%d0
  6c:	6900 0113      	bvsw 181 <main+0x14f>
    for (i = 1; i < 8; i++) {
  70:	0000 004b      	orib #75,%d0
  74:	027e           	.short 0x027e
  76:	7e06           	moveq #6,%d7
  78:	6a00 0114      	bplw 18e <main+0x15c>
  7c:	0000 004b      	orib #75,%d0
  80:	027e           	.short 0x027e
    return j;
  82:	7c06           	moveq #6,%d6
  84:	6300 0115      	blsw 19b <main+0x169>
}
  88:	0000 00af      	orib #-81,%d0
  8c:	027e           	.short 0x027e
  8e:	7b06           	mvsb %d6,%d5
  90:	6c00 0116      	bgew 1a8 <main+0x176>
  94:	0000 00b6      	orib #-74,%d0
  98:	027e           	.short 0x027e
  9a:	7606           	moveq #6,%d3
  9c:	7300           	mvsb %d0,%d1
  9e:	0117           	btst %d0,%sp@
  a0:	0000 00bd      	orib #-67,%d0
  a4:	027e           	.short 0x027e
  a6:	7200           	moveq #0,%d1
  a8:	0704           	btst %d3,%d4
  aa:	0569 6e74      	bchg %d2,%a1@(28276)
  ae:	0004 0106      	orib #6,%d4
  b2:	0000 0000      	orib #0,%d0
  b6:	0404 0500      	subib #0,%d4
  ba:	0000 0008      	orib #8,%d0
  be:	0400 0000      	subib #0,%d0
  c2:	af00           	.short 0xaf00

Disassembly of section .debug_abbrev:
00000000 <.debug_abbrev>:
short factorial(short n) {
   0:	0111           	btst %d0,%a1@
   2:	0125           	btst %d0,%a5@-
   4:	0e13           	.short 0x0e13
   6:	0b03           	btst %d5,%d3
   8:	0e1b           	.short 0x0e1b
   a:	0e11           	.short 0x0e11
    if (n <= 0) {
   c:	0112           	btst %d0,%a2@
   e:	0610 1700      	addib #0,%a0@
        return 1;
  12:	0002 2e01      	orib #1,%d2
       return(n * factorial(n - 1));
  16:	3f19           	movew %a1@+,%sp@-
  18:	030e 3a0b      	movepw %fp@(14859),%d1
  1c:	3b0b           	movew %a3,%a5@-
  1e:	2719           	movel %a1@+,%a3@-
  20:	4913           	chkl %a3@,%d4
  22:	1101           	moveb %d1,%a0@-
  24:	1206           	moveb %d6,%d1
  26:	4018           	negxb %a0@+
  28:	9642           	subw %d2,%d3
  2a:	1901           	moveb %d1,%a4@-
  2c:	1300           	moveb %d0,%a1@-
}
  2e:	0003 0500      	orib #0,%d3
{
  32:	0308 3a0b      	movepw %a0@(14859),%d1
    short i = 1;
  36:	3b0b           	movew %a3,%a5@-
  38:	4913           	chkl %a3@,%d4
  3a:	0218 0000      	andib #0,%a0@+
    short j = 2;
  3e:	0424 000b      	subib #11,%a4@-
    char  c = 'A';
  42:	0b3e           	.short 0x0b3e
  44:	0b03           	btst %d5,%d3
  46:	0e00           	.short 0x0e00
    long  l = 1234;
  48:	0005 2e01      	orib #1,%d5
  4c:	3f19           	movew %a1@+,%sp@-
  4e:	030e 3a0b      	movepw %fp@(14859),%d1
    char *s = "Hello";
  52:	3b0b           	movew %a3,%a5@-
  54:	4913           	chkl %a3@,%d4
  56:	1101           	moveb %d1,%a0@-
    for (i = 1; i < 8; i++) {
  58:	1206           	moveb %d6,%d1
  5a:	4018           	negxb %a0@+
  5c:	9642           	subw %d2,%d3
  5e:	1901           	moveb %d1,%a4@-
        j = factorial(i);
  60:	1300           	moveb %d0,%a1@-
  62:	0006 3400      	orib #0,%d6
  66:	0308 3a0b      	movepw %a0@(14859),%d1
  6a:	3b0b           	movew %a3,%a5@-
  6c:	4913           	chkl %a3@,%d4
  6e:	0218 0000      	andib #0,%a0@+
    for (i = 1; i < 8; i++) {
  72:	0724           	btst %d3,%a4@-
  74:	000b           	.short 0x000b
  76:	0b3e           	.short 0x0b3e
  78:	0b03           	btst %d5,%d3
  7a:	0800 0008      	btst #8,%d0
  7e:	0f00           	btst %d7,%d0
  80:	0b0b 4913      	movepw %a3@(18707),%d5
    return j;
  84:	0000           	Address 0x0000000000000086 is out of bounds.
Address 0x0000000000000086 is out of bounds.
.short 0x0000
	...

Disassembly of section .debug_aranges:
00000000 <.debug_aranges>:
short factorial(short n) {
   0:	0000 001c      	orib #28,%d0
   4:	0002 0000      	orib #0,%d2
   8:	0000 0400      	orib #0,%d0
	...
        return 1;
  14:	0000 008c      	orib #-116,%d0
	...

Disassembly of section .debug_line:
00000000 <.debug_line>:
short factorial(short n) {
   0:	0000 004e      	orib #78,%d0
   4:	0002 0000      	orib #0,%d2
   8:	001d 0201      	orib #1,%a5@+
    if (n <= 0) {
   c:	fb0e           	.short 0xfb0e
   e:	0d00           	btst %d6,%d0
  10:	0101           	btst %d0,%d1
        return 1;
  12:	0101           	btst %d0,%d1
  14:	0000 0001      	orib #1,%d0
       return(n * factorial(n - 1));
  18:	0000 0100      	orib #0,%d0
  1c:	6465           	bccs 83 <main+0x51>
  1e:	6d6f           	blts 8f <main+0x5d>
  20:	2e63           	moveal %a3@-,%sp
  22:	0000 0000      	orib #0,%d0
  26:	0000 0502      	orib #2,%d0
  2a:	0000 0000      	orib #0,%d0
}
  2e:	1a67           	.short 0x1a67
  30:	3d30 bc31      	movew %a0@(0000000000000031,%a3:l:4),%fp@-
{
  34:	2f3d           	.short 0x2f3d
    short i = 1;
  36:	3d3d           	.short 0x3d3d
  38:	4b4c           	.short 0x4b4c
  3a:	0002 0403      	orib #3,%d2
    short j = 2;
  3e:	4b00           	chkl %d0,%d5
  40:	0204 0381      	andib #-127,%d4
    char  c = 'A';
  44:	0002 0401      	orib #1,%d2
    long  l = 1234;
  48:	0658 064d      	addiw #1613,%a0@+
  4c:	3d02           	movew %d2,%fp@-
  4e:	0200 0101      	andib #1,%d0

Disassembly of section .debug_str:
00000000 <.debug_str>:
short factorial(short n) {
   0:	474e           	.short 0x474e
   2:	5520           	subqb #2,%a0@-
   4:	4331 3120 352e 	chkl %a1@(000000000000352e,%d3:w),%d1
   a:	342e 3020      	movew %fp@(12320),%d2
    if (n <= 0) {
   e:	2d6d 6370 753d 	movel %a5@(25456),%fp@(30013)
        return 1;
  14:	3638 3030      	movew 3030 <main+0x2ffe>,%d3
       return(n * factorial(n - 1));
  18:	3020           	movew %a0@-,%d0
  1a:	2d67 0066      	movel %sp@-,%fp@(102)
  1e:	6163           	bsrs 83 <main+0x51>
  20:	746f           	moveq #111,%d2
  22:	7269           	moveq #105,%d1
  24:	616c           	bsrs 92 <main+0x60>
  26:	0064 656d      	oriw #25965,%a4@-
  2a:	6f2e           	bles 5a <.debug_str+0x5a>
  2c:	6300 7368      	blsw 7396 <main+0x7364>
}
  30:	6f72           	bles a4 <main+0x72>
{
  32:	7420           	moveq #32,%d2
  34:	696e           	bvss a4 <main+0x72>
    short i = 1;
  36:	7400           	moveq #0,%d2
  38:	6368           	blss a2 <main+0x70>
  3a:	6172           	bsrs ae <main+0x7c>
    short j = 2;
  3c:	002f 686f 6d65 	orib #111,%sp@(28005)
    char  c = 'A';
  42:	2f74 7261 6e74 	movel %a4@(0000000000000061,%d7:w:2),%sp@(28276)
    long  l = 1234;
  48:	6572           	bcss bc <main+0x8a>
  4a:	2f67 6974      	movel %sp@-,%sp@(26996)
  4e:	2f63 5f65      	movel %a3@-,%sp@(24421)
    char *s = "Hello";
  52:	7861           	moveq #97,%d4
  54:	6d70           	blts c6 <main+0x94>
  56:	6c65           	bges bd <main+0x8b>
    for (i = 1; i < 8; i++) {
  58:	006c 6f6e 6720 	oriw #28526,%a4@(26400)
  5e:	696e           	bvss ce <main+0x9c>
        j = factorial(i);
  60:	7400           	moveq #0,%d2
  62:	6d61           	blts c5 <main+0x93>
  64:	696e           	bvss d4 <main+0xa2>
	...

Disassembly of section .comment:
00000000 <.comment>:
short factorial(short n) {
   0:	0047 4343      	oriw #17219,%d7
   4:	3a20           	movew %a0@-,%d5
   6:	2847           	moveal %d7,%a4
   8:	4e55 2920      	linkw %a5,#10528
    if (n <= 0) {
   c:	352e 342e      	movew %fp@(13358),%a2@-
  10:	3000           	movew %d0,%d0

Disassembly of section .debug_frame:
00000000 <.debug_frame>:
short factorial(short n) {
   0:	0000 0010      	orib #16,%d0
   4:	ffff           	.short 0xffff
   6:	ffff           	.short 0xffff
   8:	0100           	btst %d0,%d0
   a:	027c 180c      	andiw #6156,%sr
    if (n <= 0) {
   e:	0f04           	btst %d7,%d4
  10:	9801           	subb %d1,%d4
        return 1;
  12:	0000 0000      	orib #0,%d0
       return(n * factorial(n - 1));
  16:	0014 0000      	orib #0,%a4@
	...
  22:	0032 428e 0240 	orib #-114,%a2@(0000000000000040,%d0:w:2)
  28:	0c0e 0800      	cmpib #0,%d6
  2c:	0000 0014      	orib #20,%d0
	...
    short i = 1;
  38:	0000 005a      	orib #90,%d0
    short j = 2;
  3c:	428e           	.short 0x428e
  3e:	0240 0c0e      	andiw #3086,%d0
    char  c = 'A';
  42:	0800           	Address 0x0000000000000044 is out of bounds.
Address 0x0000000000000044 is out of bounds.
.short 0x0800
